Server Code: `(file server/server.py)`
------------------------------------

I have used `gevent.server.StreamServer` for creating the server. 
The function for computing the number of cycles given a number is different from the C version sent as it builds the memoization table bottom up instead of the top-down approach used in C code. This adds up to the startup time.

    There are two approaches to find the maximum number of cycles given a range. 
First is to iterate through the entire range and find the max. 
Second is to use Segment Trees to find the maximum value in a range.
 I have used Segment Trees . This computes max of number of cycles in O(log n) time. But eats a bit into startup time.

function `max_cycles in` class Collatz in file `collatz.py` uses the first method
function `max_cycles_r` in class Collatz in file `collatz.py` uses the second method.

Client Code: `(file: client/client.py)`
-------------------------------------
The client just asks for the number of clients to be spawned and spawns so many gevent greenlets each requesting the solution to the 3n + 1 problem for *random ranges*(generated by `random` module) and for *random number of times*. The client uses `gevent.socket` to connect to server and `gevent.spawn` to make the clients concurrent.

Results:
--------

I have tested this code on my laptop running linux with i5 processor and 4 GB RAM with a maximum of 300 concurrent clients. (Ideally client and server should have been running on different machines. But here I have tested with both the server and client running on the same machine. Assuming that the same number of greenlets have been spawned, the amount of computation the server did will be much more than what the client did. So, the results can be considered to be valid)

The variation in execution time between the two versions of computing max number of cycles is astounding.

1) When running server with `max_cycles` function for 300 concurrent clients(file: client/output/300_clients.gz):

    15070 queries processed in 664.758065939s time (i.e., 0.04411135142262773s per query)

2) When running server with `max_cycles_r` function for 300 concurrent clients(file: client/output/300_clients_RMQ.gz):

    15054 queries processed in 5.71699690819s time (i.e., 0.00037976596972166864s per query)

Currently the server code calls the `max_cycles_r` function.